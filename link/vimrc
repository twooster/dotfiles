" Modeline and Notes {
"   vim: set foldmarker={,} foldlevel=0
"
"   Originally by Robert Melton, modified heavily
" }

" Basics {
    set nocompatible       " explicitly get out of vi-compatible mode
    set noexrc             " don't use local version of .(g)vimrc, .exrc
    set background=dark    " we plan to use a dark background

    let mapleader="\<Tab>" " not a sensible leader character, but can't map
                           " space directly
    " And this makes space work:
    map <Space> <Leader>
" }

" General {
"    set autochdir                  " always switch to the current file directory
    filetype plugin indent on       " load filetype plugins/indent settings
    set autoread                    " always load updated files
    set backspace=indent,eol,start  " make backspace a more flexible
    set encoding=utf-8              " good default
    set fileformats=unix,dos,mac    " support all three, in this order
    set hidden                      " you can change buffers without saving
    set iskeyword+=_,$,@            " none of these are word dividers
    set matchpairs=(:),{:},[:],<:>  " some sane matchpairs
    set noerrorbells                " don't make noise
    set title                       " show title
    set ttyfast                     " derp
    set smarttab
    set langnoremap
    set whichwrap=b,s,~

    set wildmenu                    " turn on command line completion wild style
    " ignore these list file extensions
    set wildignore=*.dll,*.o,*.obj,*.bak,*.exe,*.pyc,
                    \*.jpg,*.gif,*.png,.git,*.swp
    set wildmode=list:longest       " turn on wild mode huge list

    " Thanks to Wincent's vimrc for this
    if has('persistent_undo')
        set undodir=~/.vim/tmp,.       " keep undo files out of the way
        set undofile                   " actually use undo files
    endif

    " Makes vim always overwrite the existing file when saving (rather than
    " doing a copy/rename); this is 'slower' but shouldn't matter on modern
    " machines, and plays nicely with common file-watching/rebuild strategies
    set backupcopy=yes
    set directory=~/.vim-tmp/swap//,.
    set backupdir=~/.vim-tmp/backup//,.
" }

" Vim UI {
    syntax on                   " syntax highlighting on
    colorscheme molokai
    set cursorline              " highlight current line
    set incsearch               " highlight as search phrase typed
    set laststatus=2            " always show the status line
    set lazyredraw              " do not redraw while running macros
    set list                    " show special characters
    " See autocmds for Go, where we drop the tab character
    let s:other_list_chars = "eol:¬,extends:»,precedes:«,trail:•"
    let &g:listchars="tab:▸\ ," . s:other_list_chars
    set matchtime=1             " how many tenths of a second to blink
                                " matching brackets for
    set nostartofline           " leave my cursor where it was
    set novisualbell            " don't blink
    set number                  " turn on line numbers
    set numberwidth=4           " good up to 9999 lines
    set report=0                " tell us when anything is changed via :...
    set ruler                   " always show current positions along the bottom
    set scrolloff=7             " keep X lines (top/bottom) for scope
    set shortmess=aOstTI        " shortens messages to avoid
                                " 'press a key' prompt
    set showcmd                 " show the command being typed
    set showmatch               " show matching brackets
    set sidescrolloff=10        " keep X characters at the sides
    set hlsearch
    set history=10000

    set statusline=
    set statusline+=%<\                       " cut at start
    set statusline+=%2*[%n%H%M%R%W]%*\        " flags and buf no
    set statusline+=%-40F\                    " path
    set statusline+=%=%1*%y%*%*\              " file type
    set statusline+=%10((%l,%c)%)\            " line and column
    set statusline+=%P                        " percentage of file

    " [via Shane da Silva's dotfiles, and seen elsewhere]
    " Disable Background Color Erase (BCE) so that color schemes
    " work properly when Vim is used inside tmux and GNU screen.
    if &term =~ '256color'
        set t_ut=
    endif
" }

" Text Formatting/Layout {
"    set completeopt= " don't use a pop up menu for completions
    set expandtab          " no real tabs please!
    set formatoptions+=q   " Allow commenting formatting with 'gq'
    set formatoptions+=r   " Insert comment leader after hitting <enter> in INS
    set formatoptions+=j   " Remove comment leader when joining lines
    set ignorecase         " case insensitive by default
    set infercase          " case inferred by default
    set nowrap             " do not wrap line
    "set shiftround         " when at 3 spaces, and I hit > ... go to 4, not 5
    set shiftwidth=2       " auto-indent amount when using cindent,
    set smartcase          " if there are caps, go case-sensitive
    set smartindent        " Slightly smarter indentation
    "set autondent          " Previous line indentation
    "set cindent            " Smarter still
    set softtabstop=2      " tab converted to X spaces
    set tabstop=8          " real tabs X spaces wide

    " Sets up past-80-column highlighting
    "highlight OverLength ctermbg=red ctermfg=white guibg=#592929
    if &t_Co > 255
        highlight OverLength ctermbg=52 guibg=#592929
    else
        highlight OverLength ctermbg=1 guibg=#592929
    endif
    match OverLength /\%81v.\+/

    " Python syntax highlighting {
        let python_highlight_all = 1
        let python_slow_sync = 1
    " }

" }

" Folding {
    set foldmethod=syntax
    set foldlevel=99
" }

" Plugins {
    call plug#begin('~/.vim/plugged')

    Plug 'tpope/vim-repeat'
    Plug 'tpope/vim-surround'
    Plug 'junegunn/vim-easy-align'
    Plug 'scrooloose/nerdcommenter'
    Plug 'easymotion/vim-easymotion'

    Plug 'tpope/vim-fugitive'

    Plug 'tpope/vim-rails'             ", { 'for': 'ruby' }
    Plug 'tpope/vim-markdown'          ", { 'for': 'markdown' }
    Plug 'tpope/vim-haml'              ", { 'for': 'haml' }
    Plug 'elixir-lang/vim-elixir'      ", { 'for': 'elixir' }
    Plug 'pangloss/vim-javascript'     ", { 'for': 'javascript' }
    Plug 'mxw/vim-jsx'                 ", { 'for': 'javascript' }
    Plug 'leafgarland/typescript-vim'  ", { 'for': 'javascript' }
    Plug 'lepture/vim-jinja'           ", { 'for': 'jinja' }

    Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --bin' }
    Plug 'junegunn/fzf.vim'

    " From this discussion ... I like the install guard:
    " https://github.com/Valloric/YouCompleteMe/issues/1751
    function! BuildYCM(info)
        " info is a dictionary with 3 fields
        " - name:   name of the plugin
        " - status: 'installed', 'updated', or 'unchanged'
        " - force:  set on PlugInstall! or PlugUpdate!
        if a:info.status == 'installed' || a:info.force
          !./install.py
        endif
    endfunction

    Plug 'Valloric/YouCompleteMe', { 'do': function('BuildYCM') }

    call plug#end()
" }

" Matchit Settings {
    let b:match_ignorecase = 1 " case is stupid
" }

" FZF settings {
  " Teach fzf.vim about rg:
    if executable('rg')
        function! FzfRg(query, ...)
            if type(a:query) != type('')
              return s:warn('Invalid query argument')
            endif
            let query = empty(a:query) ? '^(?=.)' : a:query
            let command = fzf#shellescape(query)
            return call('fzf#vim#grep', extend(['rg --column --color always '.command, 1], a:000))
        endfunction

        command! -bang -nargs=* Ag call FzfRg(<q-args>, <bang>0)
    endif

    map <Leader>t :Files<CR>
    map <Leader>b :Buffers<CR>
    map <Leader>g :Ag<Space>
" }

"" Syntastic Settings {
"    let g:syntastic_haml_checkers = ['haml_lint']
"" }


"" NERDTree Settings {
"    let NERDTreeIgnore = ['\.pyc$']
"
"    map <Leader>N :NERDTreeToggle<CR>
"    map <Leader>n :NERDTree<CR>
"" }

" NERDCommenter Settings {
    let g:NERDCommentEmptyLines = 1
" }

" Basic mappings {
    " The 'I hate esc' section
    imap jj <esc>

    " The 'make Y behave like C and D" section
    nnoremap Y y$

    " The 'sane searching' section
    nnoremap / /\v
    vnoremap / /\V%

    " The fuck netrw section
    map - <Nop>

    " The F1-is-too-close-to-esc section
    map <F1> <Nop>

    " The 'make moving around windows easy' section
    noremap <Leader>h <C-w>h
    noremap <Leader>j <C-w>j
    noremap <Leader>k <C-w>k
    noremap <Leader>l <C-w>l

    " The 'visual instead of logical lines' section
    nnoremap j gj
    nnoremap k gk


    " The 'make switching quote-types easy' section
    nmap <Leader>' mzcs"'`z
    nmap <Leader>" mzcs'"`z

    " The colons are hard section
    map <Leader>; :
    map <Leader>q :q<CR>
    map <Leader>w :w<CR>
    map <Leader>x :x<CR>

    " The linux clipboard section
    "if has('clipboard')
    "  map <Leader>y :let @*=@"<cr>:echo Copied to system Clipboard<cr>
    "  nnoremap <Leader>p "*p
    "  nnoremap <Leader>P "*P
    "else
      map <Leader>y :w  !xclip -selection clipboard<cr>
      map <Leader>p :r  !xclip -selection clipboard -o<cr>
      map <Leader>P k:r !xclip -selection clipboard -o<cr>
    "endif

    " Delete current buffer, move to previous
    nmap <leader>d :bprevious<CR>:bdelete #<CR>

    " Highlighting debugging:
    " map <C-F10> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

    " Sort lines inside current paragraph
    "nmap <Leader>s mzvi}:sort<CR>`z
    " Sort selected lines
    vmap <Leader>s :sort<CR>

    " The 'Make splitting more like tmux' section
    nmap <Leader>\     :vsp<CR>
    nmap <Leader><Bar> :vsp<CR>
    nmap <Leader>-     :sp<CR>

    " Command mode readline mappings
    cnoremap <C-a> <Home>
    cnoremap <C-e> <End>

    " redraw arg!
    nmap <Leader>r :redraw!<CR>

    " Folding...
    "nnoremap <Leader>f za
" }

" EasyMotion Settings {
    let g:EasyMotion_do_mapping=0  " Disable default mappings
    let g:EasyMotion_smartcase=1
    let g:EasyMotion_use_smartsign_us=1
    let g:EasyMotion_startofline=0

    map  <C-s>     <Plug>(easymotion-overwin-f)
    map  <C-a>     <Plug>(easymotion-overwin-f2)
    nmap <Leader>/ <Plug>(easymotion-sn)
    omap <Leader>/ <Plug>(easymotion-tn)

    map  <C-h>     <Plug>(easymotion-linebackward)
    map  <C-k>     <Plug>(easymotion-k)
    map  <C-j>     <Plug>(easymotion-j)
    map  <C-l>     <Plug>(easymotion-lineforward)

    map  <C-w>     <Plug>(easymotion-bd-w)
    map  <C-f>     <Plug>(easymotion-bd-f)
    map  <C-t>     <Plug>(easymotion-bd-t)
" }

" vim-easy-align settings {
    " Start interactive EasyAlign in visual mode (e.g. vipga)
    xmap <Leader>a <Plug>(EasyAlign)
    "
    " " Start interactive EasyAlign for a motion/text object (e.g. gaip)
    nmap <Leader>a <Plug>(EasyAlign)
" }

" Also from @sds by way of @wincent, by way of ?
" Support 'bracketed-paste' mode, allowing pasting large chunks of text without
" having to manually activate PASTE mode.
if &term =~ "xterm.*"
    let &t_ti = &t_ti . "\e[?2004h"
    let &t_te = "\e[?2004l" . &t_te

    function! XTermPasteBegin(ret)
        set pastetoggle=<Esc>[201~
        set paste
        return a:ret
    endfunction

    map  <expr>     <Esc>[200~ XTermPasteBegin("i")
    imap <expr>     <Esc>[200~ XTermPasteBegin("")
    cmap <Esc>[200~ <nop>
    cmap <Esc>[201~ <nop>
endif

" Autocommands {
    " Salt state files:
    au BufNewFile,BufRead *.sls setlocal filetype=yaml

    au FileType ruby       setlocal tabstop=2 softtabstop=2 shiftwidth=2
    au FileType python     setlocal tabstop=8 softtabstop=4 shiftwidth=4 cindent
                       \ | syn keyword pythonAwait await
                       \ | hi def link pythonAwait Keyword
                       \ | syn keyword pythonAsync async
                       \ | hi def link pythonAsync Keyword
    au FileType javascript setlocal tabstop=2 softtabstop=2 shiftwidth=2 cindent
    au FileType css        setlocal tabstop=2 softtabstop=2 shiftwidth=2
    au FileType php        setlocal noet shiftwidth=2 softtabstop=2 tabstop=2
    au FileType go         setlocal noet shiftwidth=4 tabstop=4
                       \ | let &l:listchars = "tab:\ \ ," . s:other_list_chars
    au FileType gitcommit  setlocal textwidth=70 fo+=t

    " Remove all trailing whitespace on save
    au BufWritePre * :%s/\s\+$//e

    " disable paste mode on leaving insert mode (thanks @wincent)
    au InsertLeave * set nopaste
" }

" GUI Settings {
if has("gui_running")
    set linespace=0             " don't insert any extra pixel lines
                                " betweens rows
    " Basics {
        set columns=120
        set guioptions=ce
        "              ||
        "              |+-- use simple dialogs rather than pop-ups
        "              +  use GUI tabs, not console style tabs
        set mousehide " hide the mouse cursor when typing
        set transp=4 " a little bit of transparency for macvim
    " }
endif
" }
